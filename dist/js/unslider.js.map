{"version":3,"sources":["webpack:///js/unslider.js","webpack:///./src/tool/util/unslider/index.js","webpack:///./src/tool/util/unslider/unslider.min.js","webpack:///(webpack)/buildin/module.js"],"names":["webpackJsonp","module","exports","__webpack_require__","jQuery","__webpack_provided_window_dot_jQuery","__WEBPACK_AMD_DEFINE_FACTORY__","__WEBPACK_AMD_DEFINE_ARRAY__","__WEBPACK_AMD_DEFINE_RESULT__","_typeof","Symbol","iterator","obj","constructor","prototype","factory","undefined","apply","$","console","warn","Unslider","context","options","self","this","_","defaults","autoplay","delay","speed","easing","keys","prev","next","nav","arrows","animation","selectors","container","slides","animateHeight","activeClass","swipe","swipeThreshold","$context","$parent","$container","$slides","$nav","$arrows","total","current","prefix","eventSuffix","Math","random","interval","init","extend","find","addClass","children","setup","each","index","_ucfirst","event","special","initSwipe","start","calculateSlides","trigger","animate","wrap","parent","css","length","prop","push","setTimeout","stop","timeout","pop","clearTimeout","initNav","key","label","getAttribute","isFunction","call","eq","append","insertAfter","on","e","$me","siblings","removeClass","attr","initArrows","val","initKeys","document","which","width","movestart","distX","distY","preventDefault","move","moveend","abs","left","initInfinite","pos","item","filter","clone","destroyArrows","i","$arrow","remove","destroySwipe","off","destroyKeys","setIndex","to","min","max","_active","dir","isNaN","fn","target","noloop","infinite","animateHorizontal","slide","animateVertical","outerHeight","dummy","_move","height","$el","callback","className","str","toLowerCase","replace","match","toUpperCase","velocity","arguments","unslider","opts","elem","$this","data","split","webpackPolyfill","deprecate","paths","Object","defineProperty","enumerable","get","l"],"mappings":"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","file":"js/unslider.js","sourcesContent":["webpackJsonp([3],[\n/* 0 */,\n/* 1 */,\n/* 2 */,\n/* 3 */,\n/* 4 */,\n/* 5 */,\n/* 6 */,\n/* 7 */,\n/* 8 */,\n/* 9 */,\n/* 10 */,\n/* 11 */,\n/* 12 */,\n/* 13 */,\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\nmodule.exports = __webpack_require__(15);\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\n\n/*\r\n * @Author: guidetheorient \r\n * @Date: 2018-04-05 05:34:17 \r\n * @Last Modified by: guidetheorient\r\n * @Last Modified time: 2018-04-05 05:55:51\r\n */\n\n__webpack_require__(16);\n__webpack_require__(18);\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(jQuery, module, __webpack_provided_window_dot_jQuery) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n/**\r\n *   Unslider\r\n *   version 2.0\r\n *   by @idiot and friends\r\n */\n\n(function (factory) {\n\tif (( false ? 'undefined' : _typeof(module)) === 'object' && _typeof(module.exports) === 'object') {\n\t\tfactory(__webpack_require__(1));\n\t} else if (true) {\n\t\t// AMD. Register as an anonymous module.\n\t\t!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory(__webpack_provided_window_dot_jQuery)),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n\t} else {\n\t\tfactory(window.jQuery);\n\t}\n})(function ($) {\n\t//  Don't throw any errors when jQuery\n\tif (!$) {\n\t\treturn console.warn('Unslider needs jQuery');\n\t}\n\n\t$.Unslider = function (context, options) {\n\t\tvar self = this;\n\n\t\t//  Create an Unslider reference we can use everywhere\n\t\tself._ = 'unslider';\n\n\t\t//  Store our default options in here\n\t\t//  Everything will be overwritten by the jQuery plugin though\n\t\tself.defaults = {\n\t\t\t//  Should the slider move on its own or only when\n\t\t\t//  you interact with the nav/arrows?\n\t\t\t//  Only accepts boolean true/false.\n\t\t\tautoplay: false,\n\n\t\t\t//  3 second delay between slides moving, pass\n\t\t\t//  as a number in milliseconds.\n\t\t\tdelay: 3000,\n\n\t\t\t//  Animation speed in millseconds\n\t\t\tspeed: 750,\n\n\t\t\t//  An easing string to use. If you're using Velocity, use a\n\t\t\t//  Velocity string otherwise you can use jQuery/jQ UI options.\n\t\t\teasing: 'swing', // [.42, 0, .58, 1],\n\n\t\t\t//  Does it support keyboard arrows?\n\t\t\t//  Can pass either true or false -\n\t\t\t//  or an object with the keycodes, like so:\n\t\t\t//  {\n\t\t\t//\t prev: 37,\n\t\t\t//\t next: 39\n\t\t\t// }\n\t\t\t//  You can call any internal method name\n\t\t\t//  before the keycode and it'll be called.\n\t\t\tkeys: {\n\t\t\t\tprev: 37,\n\t\t\t\tnext: 39\n\t\t\t},\n\n\t\t\t//  Do you want to generate clickable navigation\n\t\t\t//  to skip to each slide? Accepts boolean true/false or\n\t\t\t//  a callback function per item to generate.\n\t\t\tnav: true,\n\n\t\t\t//  Should there be left/right arrows to go back/forth?\n\t\t\t//   -> This isn't keyboard support.\n\t\t\t//  Either set true/false, or an object with the HTML\n\t\t\t//  elements for each arrow like below:\n\t\t\tarrows: {\n\t\t\t\tprev: '<a class=\"' + self._ + '-arrow prev\">Prev</a>',\n\t\t\t\tnext: '<a class=\"' + self._ + '-arrow next\">Next</a>'\n\t\t\t},\n\n\t\t\t//  How should Unslider animate?\n\t\t\t//  It can do one of the following types:\n\t\t\t//  \"fade\": each slide fades in to each other\n\t\t\t//  \"horizontal\": each slide moves from left to right\n\t\t\t//  \"vertical\": each slide moves from top to bottom\n\t\t\tanimation: 'horizontal',\n\n\t\t\t//  If you don't want to use a list to display your slides,\n\t\t\t//  you can change it here. Not recommended and you'll need\n\t\t\t//  to adjust the CSS accordingly.\n\t\t\tselectors: {\n\t\t\t\tcontainer: 'ul:first',\n\t\t\t\tslides: 'li'\n\t\t\t},\n\n\t\t\t//  Do you want to animate the heights of each slide as\n\t\t\t//  it moves\n\t\t\tanimateHeight: false,\n\n\t\t\t//  Active class for the nav\n\t\t\tactiveClass: self._ + '-active',\n\n\t\t\t//  Have swipe support?\n\t\t\t//  You can set this here with a boolean and always use\n\t\t\t//  initSwipe/destroySwipe later on.\n\t\t\tswipe: true,\n\t\t\t// Swipe threshold -\n\t\t\t// lower float for enabling short swipe\n\t\t\tswipeThreshold: 0.2\n\t\t};\n\n\t\t//  Set defaults\n\t\tself.$context = context;\n\t\tself.options = {};\n\n\t\t//  Leave our elements blank for now\n\t\t//  Since they get changed by the options, we'll need to\n\t\t//  set them in the init method.\n\t\tself.$parent = null;\n\t\tself.$container = null;\n\t\tself.$slides = null;\n\t\tself.$nav = null;\n\t\tself.$arrows = [];\n\n\t\t//  Set our indexes and totals\n\t\tself.total = 0;\n\t\tself.current = 0;\n\n\t\t//  Generate a specific random ID so we don't dupe events\n\t\tself.prefix = self._ + '-';\n\t\tself.eventSuffix = '.' + self.prefix + ~~(Math.random() * 2e3);\n\n\t\t//  In case we're going to use the autoplay\n\t\tself.interval = [];\n\n\t\t//  Get everything set up innit\n\t\tself.init = function (options) {\n\t\t\t//  Set up our options inside here so we can re-init at\n\t\t\t//  any time\n\t\t\tself.options = $.extend({}, self.defaults, options);\n\n\t\t\t//  Our elements\n\t\t\tself.$container = self.$context.find(self.options.selectors.container).addClass(self.prefix + 'wrap');\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\n\n\t\t\t//  We'll manually init the container\n\t\t\tself.setup();\n\n\t\t\t//  We want to keep this script as small as possible\n\t\t\t//  so we'll optimise some checks\n\t\t\t$.each(['nav', 'arrows', 'keys', 'infinite'], function (index, module) {\n\t\t\t\tself.options[module] && self['init' + $._ucfirst(module)]();\n\t\t\t});\n\n\t\t\t//  Add swipe support\n\t\t\tif (jQuery.event.special.swipe && self.options.swipe) {\n\t\t\t\tself.initSwipe();\n\t\t\t}\n\n\t\t\t//  If autoplay is set to true, call self.start()\n\t\t\t//  to start calling our timeouts\n\t\t\tself.options.autoplay && self.start();\n\n\t\t\t//  We should be able to recalculate slides at will\n\t\t\tself.calculateSlides();\n\n\t\t\t//  Listen to a ready event\n\t\t\tself.$context.trigger(self._ + '.ready');\n\n\t\t\t//  Everyday I'm chainin'\n\t\t\treturn self.animate(self.options.index || self.current, 'init');\n\t\t};\n\n\t\tself.setup = function () {\n\t\t\t//  Add a CSS hook to the main element\n\t\t\tself.$context.addClass(self.prefix + self.options.animation).wrap('<div class=\"' + self._ + '\" />');\n\t\t\tself.$parent = self.$context.parent('.' + self._);\n\n\t\t\t//  We need to manually check if the container is absolutely\n\t\t\t//  or relatively positioned\n\t\t\tvar position = self.$context.css('position');\n\n\t\t\t//  If we don't already have a position set, we'll\n\t\t\t//  automatically set it ourselves\n\t\t\tif (position === 'static') {\n\t\t\t\tself.$context.css('position', 'relative');\n\t\t\t}\n\n\t\t\tself.$context.css('overflow', 'hidden');\n\t\t};\n\n\t\t//  Set up the slide widths to animate with\n\t\t//  so the box doesn't float over\n\t\tself.calculateSlides = function () {\n\t\t\t// update slides before recalculating the total\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\n\n\t\t\tself.total = self.$slides.length;\n\n\t\t\t//  Set the total width\n\t\t\tif (self.options.animation !== 'fade') {\n\t\t\t\tvar prop = 'width';\n\n\t\t\t\tif (self.options.animation === 'vertical') {\n\t\t\t\t\tprop = 'height';\n\t\t\t\t}\n\n\t\t\t\tself.$container.css(prop, self.total * 100 + '%').addClass(self.prefix + 'carousel');\n\t\t\t\tself.$slides.css(prop, 100 / self.total + '%');\n\t\t\t}\n\t\t};\n\n\t\t//  Start our autoplay\n\t\tself.start = function () {\n\t\t\tself.interval.push(setTimeout(function () {\n\t\t\t\t//  Move on to the next slide\n\t\t\t\tself.next();\n\n\t\t\t\t//  If we've got autoplay set up\n\t\t\t\t//  we don't need to keep starting\n\t\t\t\t//  the slider from within our timeout\n\t\t\t\t//  as .animate() calls it for us\n\t\t\t}, self.options.delay));\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  And pause our timeouts\n\t\t//  and force stop the slider if needed\n\t\tself.stop = function () {\n\t\t\tvar timeout;\n\t\t\twhile (timeout = self.interval.pop()) {\n\t\t\t\tclearTimeout(timeout);\n\t\t\t}\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  Set up our navigation\n\t\tself.initNav = function () {\n\t\t\tvar $nav = $('<nav class=\"' + self.prefix + 'nav\"><ol /></nav>');\n\n\t\t\t//  Build our click navigation item-by-item\n\t\t\tself.$slides.each(function (key) {\n\t\t\t\t//  If we've already set a label, let's use that\n\t\t\t\t//  instead of generating one\n\t\t\t\tvar label = this.getAttribute('data-nav') || key + 1;\n\n\t\t\t\t//  Listen to any callback functions\n\t\t\t\tif ($.isFunction(self.options.nav)) {\n\t\t\t\t\tlabel = self.options.nav.call(self.$slides.eq(key), key, label);\n\t\t\t\t}\n\n\t\t\t\t//  And add it to our navigation item\n\t\t\t\t$nav.children('ol').append('<li data-slide=\"' + key + '\">' + label + '</li>');\n\t\t\t});\n\n\t\t\t//  Keep a copy of the nav everywhere so we can use it\n\t\t\tself.$nav = $nav.insertAfter(self.$context);\n\n\t\t\t//  Now our nav is built, let's add it to the slider and bind\n\t\t\t//  for any click events on the generated links\n\t\t\tself.$nav.find('li').on('mouseenter' + self.eventSuffix, function (e) {\n\t\t\t\t//  Cache our link and set it to be active\n\t\t\t\tvar $me = $(this).addClass(self.options.activeClass);\n\n\t\t\t\t//  Set the right active class, remove any other ones\n\t\t\t\t$me.siblings().removeClass(self.options.activeClass);\n\n\t\t\t\t//  Move the slide\n\t\t\t\tself.animate($me.attr('data-slide'));\n\t\t\t});\n\t\t};\n\n\t\t//  Set up our left-right arrow navigation\n\t\t//  (Not keyboard arrows, prev/next buttons)\n\t\tself.initArrows = function () {\n\t\t\tif (self.options.arrows === true) {\n\t\t\t\tself.options.arrows = self.defaults.arrows;\n\t\t\t}\n\n\t\t\t//  Loop our options object and bind our events\n\t\t\t$.each(self.options.arrows, function (key, val) {\n\t\t\t\t//  Add our arrow HTML and bind it\n\n\t\t\t\tself.$arrows.push($(val).insertAfter(self.$context).on('click' + self.eventSuffix, self[key]));\n\t\t\t});\n\t\t};\n\n\t\t//  Set up our keyboad navigation\n\t\t//  Allow binding to multiple keycodes\n\t\tself.initKeys = function () {\n\t\t\tif (self.options.keys === true) {\n\t\t\t\tself.options.keys = self.defaults.keys;\n\t\t\t}\n\n\t\t\t$(document).on('keyup' + self.eventSuffix, function (e) {\n\t\t\t\t$.each(self.options.keys, function (key, val) {\n\t\t\t\t\tif (e.which === val) {\n\t\t\t\t\t\t$.isFunction(self[key]) && self[key].call(self);\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t//  Requires jQuery.event.swipe\n\t\t//  -> stephband.info/jquery.event.swipe\n\t\tself.initSwipe = function () {\n\t\t\tvar width = self.$slides.width();\n\n\t\t\t//  We don't want to have a tactile swipe in the slider\n\t\t\t//  in the fade animation, as it can cause some problems\n\t\t\t//  with layout, so we'll just disable it.\n\t\t\tif (self.options.animation !== 'fade') {\n\n\t\t\t\tself.$container.on({\n\n\t\t\t\t\tmovestart: function movestart(e) {\n\t\t\t\t\t\t//  If the movestart heads off in a upwards or downwards\n\t\t\t\t\t\t//  direction, prevent it so that the browser scrolls normally.\n\t\t\t\t\t\tif (e.distX > e.distY && e.distX < -e.distY || e.distX < e.distY && e.distX > -e.distY) {\n\t\t\t\t\t\t\treturn !!e.preventDefault();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tself.$container.css('position', 'relative');\n\t\t\t\t\t},\n\n\t\t\t\t\tmove: function move(e) {\n\t\t\t\t\t\tself.$container.css('left', -(100 * self.current) + 100 * e.distX / width + '%');\n\t\t\t\t\t},\n\n\t\t\t\t\tmoveend: function moveend(e) {\n\t\t\t\t\t\t// Check if swiped distance is greater than threshold.\n\t\t\t\t\t\t// If yes slide to next/prev slide. If not animate to\n\t\t\t\t\t\t// starting point.\n\n\t\t\t\t\t\tif (Math.abs(e.distX) / width > self.options.swipeThreshold) {\n\n\t\t\t\t\t\t\tself[e.distX < 0 ? 'next' : 'prev']();\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\tself.$container.animate({ left: -(100 * self.current) + '%' }, self.options.speed / 2);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\t//  Infinite scrolling is a massive pain in the arse\n\t\t//  so we need to create a whole bloody function to set\n\t\t//  it up. Argh.\n\t\tself.initInfinite = function () {\n\t\t\tvar pos = ['first', 'last'];\n\n\t\t\t$.each(pos, function (index, item) {\n\t\t\t\tself.$slides.push.apply(self.$slides,\n\n\t\t\t\t//  Exclude all cloned slides and call .first() or .last()\n\t\t\t\t//  depending on what `item` is.\n\t\t\t\tself.$slides.filter(':not(\".' + self._ + '-clone\")')[item]()\n\n\t\t\t\t//  Make a copy of it and identify it as a clone\n\t\t\t\t.clone().addClass(self._ + '-clone')\n\n\t\t\t\t//  Either insert before or after depending on whether we're\n\t\t\t\t//  the first or last clone\n\t\t\t\t['insert' + (index === 0 ? 'After' : 'Before')](\n\t\t\t\t//  Return the other element in the position array\n\t\t\t\t//  if item = first, return \"last\"\n\t\t\t\tself.$slides[pos[~~!index]]()));\n\t\t\t});\n\t\t};\n\n\t\t//  Remove any trace of arrows\n\t\t//  Loop our array of arrows and use jQuery to remove\n\t\t//  It'll unbind any event handlers for us\n\t\tself.destroyArrows = function () {\n\t\t\t$.each(self.$arrows, function (i, $arrow) {\n\t\t\t\t$arrow.remove();\n\t\t\t});\n\t\t};\n\n\t\t//  Remove any swipe events and reset the position\n\t\tself.destroySwipe = function () {\n\t\t\t//  We bind to 4 events, so we'll unbind those\n\t\t\tself.$container.off('movestart move moveend');\n\t\t};\n\n\t\t//  Unset the keyboard navigation\n\t\t//  Remove the handler\n\t\tself.destroyKeys = function () {\n\t\t\t//  Remove the event handler\n\t\t\t$(document).off('keyup' + self.eventSuffix);\n\t\t};\n\n\t\tself.setIndex = function (to) {\n\t\t\tif (to < 0) {\n\t\t\t\tto = self.total - 1;\n\t\t\t}\n\n\t\t\tself.current = Math.min(Math.max(0, to), self.total - 1);\n\n\t\t\tif (self.options.nav) {\n\t\t\t\tself.$nav.find('[data-slide=\"' + self.current + '\"]')._active(self.options.activeClass);\n\t\t\t}\n\n\t\t\tself.$slides.eq(self.current)._active(self.options.activeClass);\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  Despite the name, this doesn't do any animation - since there's\n\t\t//  now three different types of animation, we let this method delegate\n\t\t//  to the right type, keeping the name for backwards compat.\n\t\tself.animate = function (to, dir) {\n\t\t\t//  Animation shortcuts\n\t\t\t//  Instead of passing a number index, we can now\n\t\t\t//  use .data('unslider').animate('last');\n\t\t\t//  or .unslider('animate:last')\n\t\t\t//  to go to the very last slide\n\t\t\tif (to === 'first') to = 0;\n\t\t\tif (to === 'last') to = self.total;\n\n\t\t\t//  Don't animate if it's not a valid index\n\t\t\tif (isNaN(to)) {\n\t\t\t\treturn self;\n\t\t\t}\n\n\t\t\tif (self.options.autoplay) {\n\t\t\t\tself.stop().start();\n\t\t\t}\n\n\t\t\tself.setIndex(to);\n\n\t\t\t//  Add a callback method to do stuff with\n\t\t\tself.$context.trigger(self._ + '.change', [to, self.$slides.eq(to)]);\n\n\t\t\t//  Delegate the right method - everything's named consistently\n\t\t\t//  so we can assume it'll be called \"animate\" +\n\t\t\tvar fn = 'animate' + $._ucfirst(self.options.animation);\n\n\t\t\t//  Make sure it's a valid animation method, otherwise we'll get\n\t\t\t//  a load of bug reports that'll be really hard to report\n\t\t\tif ($.isFunction(self[fn])) {\n\t\t\t\tself[fn](self.current, dir);\n\t\t\t}\n\n\t\t\treturn self;\n\t\t};\n\n\t\t//  Shortcuts for animating if we don't know what the current\n\t\t//  index is (i.e back/forward)\n\t\t//  For moving forward we need to make sure we don't overshoot.\n\t\tself.next = function () {\n\t\t\tvar target = self.current + 1;\n\n\t\t\t//  If we're at the end, we need to move back to the start\n\t\t\tif (target >= self.total) {\n\t\t\t\tif (self.options.noloop && !self.options.infinite) {\n\t\t\t\t\ttarget = self.total - 1;\n\t\t\t\t} else {\n\t\t\t\t\ttarget = 0;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn self.animate(target, 'next');\n\t\t};\n\n\t\t//  The same as next, but the opposite :)\n\t\tself.prev = function () {\n\t\t\tvar target = self.current - 1;\n\n\t\t\t//  If we're at the first, we need to move forward to the end\n\t\t\tif (target < 0) {\n\t\t\t\tif (self.options.noloop && !self.options.infinite) {\n\t\t\t\t\ttarget = 0;\n\t\t\t\t} else {\n\t\t\t\t\ttarget = self.total - 1;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn self.animate(target, 'prev');\n\t\t};\n\n\t\t//  Our default animation method, the old-school left-to-right\n\t\t//  horizontal animation\n\t\tself.animateHorizontal = function (to) {\n\t\t\tvar prop = 'left';\n\n\t\t\t//  Add RTL support, slide the slider\n\t\t\t//  the other way if the site is right-to-left\n\t\t\tif (self.$context.attr('dir') === 'rtl') {\n\t\t\t\tprop = 'right';\n\t\t\t}\n\n\t\t\tif (self.options.infinite) {\n\t\t\t\t//  So then we need to hide the first slide\n\t\t\t\tself.$container.css('margin-' + prop, '-100%');\n\t\t\t}\n\n\t\t\treturn self.slide(prop, to);\n\t\t};\n\n\t\t//  The same animation methods, but vertical support\n\t\t//  RTL doesn't affect the vertical direction so we\n\t\t//  can just call as is\n\t\tself.animateVertical = function (to) {\n\t\t\tself.options.animateHeight = true;\n\n\t\t\t//  Normal infinite CSS fix doesn't work for\n\t\t\t//  vertical animation so we need to manually set it\n\t\t\t//  with pixels. Ah well.\n\t\t\tif (self.options.infinite) {\n\t\t\t\tself.$container.css('margin-top', -self.$slides.outerHeight());\n\t\t\t}\n\n\t\t\treturn self.slide('top', to);\n\t\t};\n\n\t\t//  Actually move the slide now\n\t\t//  We have to pass a property to animate as there's\n\t\t//  a few different directions it can now move, but it's\n\t\t//  otherwise unchanged from before.\n\t\tself.slide = function (prop, to) {\n\t\t\t//  If we want to change the height of the slider\n\t\t\t//  to match the current slide, you can set\n\t\t\t//  {animateHeight: true}\n\t\t\tself.animateHeight(to);\n\n\t\t\t//  For infinite sliding we add a dummy slide at the end and start\n\t\t\t//  of each slider to give the appearance of being infinite\n\t\t\tif (self.options.infinite) {\n\t\t\t\tvar dummy;\n\n\t\t\t\t//  Going backwards to last slide\n\t\t\t\tif (to === self.total - 1) {\n\t\t\t\t\t//  We're setting a dummy position and an actual one\n\t\t\t\t\t//  the dummy is what the index looks like\n\t\t\t\t\t//  (and what we'll silently update to afterwards),\n\t\t\t\t\t//  and the actual is what makes it not go backwards\n\t\t\t\t\tdummy = self.total - 3;\n\t\t\t\t\tto = -1;\n\t\t\t\t}\n\n\t\t\t\t//  Going forwards to first slide\n\t\t\t\tif (to === self.total - 2) {\n\t\t\t\t\tdummy = 0;\n\t\t\t\t\tto = self.total - 2;\n\t\t\t\t}\n\n\t\t\t\t//  If it's a number we can safely set it\n\t\t\t\tif (typeof dummy === 'number') {\n\t\t\t\t\tself.setIndex(dummy);\n\n\t\t\t\t\t//  Listen for when the slide's finished transitioning so\n\t\t\t\t\t//  we can silently move it into the right place and clear\n\t\t\t\t\t//  this whole mess up.\n\t\t\t\t\tself.$context.on(self._ + '.moved', function () {\n\t\t\t\t\t\tif (self.current === dummy) {\n\t\t\t\t\t\t\tself.$container.css(prop, -(100 * dummy) + '%').off(self._ + '.moved');\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t//  We need to create an object to store our property in\n\t\t\t//  since we don't know what it'll be.\n\t\t\tvar obj = {};\n\n\t\t\t//  Manually create it here\n\t\t\tobj[prop] = -(100 * to) + '%';\n\n\t\t\t//  And animate using our newly-created object\n\t\t\treturn self._move(self.$container, obj);\n\t\t};\n\n\t\t//  Fade between slides rather than, uh, sliding it\n\t\t// self.animateFade = function(to) {\n\t\t// \t//  If we want to change the height of the slider\n\t\t// \t//  to match the current slide, you can set\n\t\t// \t//  {animateHeight: true}\n\t\t// \tself.animateHeight(to);\n\n\n\t\t// \tvar $active = self.$slides.eq(to).addClass(self.options.activeClass);\n\n\t\t// \t//  Toggle our classes\n\t\t// \t$active.css({opacity: 1}).siblings().css({opacity: 0});\n\t\t// };\n\n\t\t// Animate height of slider\n\t\tself.animateHeight = function (to) {\n\t\t\t//  If we want to change the height of the slider\n\t\t\t//  to match the current slide, you can set\n\t\t\t//  {animateHeight: true}\n\t\t\tif (self.options.animateHeight) {\n\t\t\t\tself._move(self.$context, { height: self.$slides.eq(to).outerHeight() }, false);\n\t\t\t}\n\t\t};\n\n\t\tself._move = function ($el, obj, callback, speed) {\n\t\t\tif (callback !== false) {\n\t\t\t\tcallback = function callback() {\n\t\t\t\t\tself.$context.trigger(self._ + '.moved');\n\t\t\t\t};\n\t\t\t}\n\n\t\t\treturn $el._move(obj, speed || self.options.speed, self.options.easing, callback);\n\t\t};\n\n\t\t//  Allow daisy-chaining of methods\n\t\treturn self.init(options);\n\t};\n\n\t//  Internal (but global) jQuery methods\n\t//  They're both just helpful types of shorthand for\n\t//  anything that might take too long to write out or\n\t//  something that might be used more than once.\n\t$.fn._active = function (className) {\n\t\treturn this.addClass(className).siblings().removeClass(className);\n\t};\n\n\t//  The equivalent to PHP's ucfirst(). Take the first\n\t//  character of a string and make it uppercase.\n\t//  Simples.\n\t$._ucfirst = function (str) {\n\t\t//  Take our variable, run a regex on the first letter\n\t\treturn (str + '').toLowerCase().replace(/^./, function (match) {\n\t\t\t//  And uppercase it. Simples.\n\t\t\treturn match.toUpperCase();\n\t\t});\n\t};\n\n\t$.fn._move = function () {\n\t\tthis.stop(true, true);\n\t\treturn $.fn[$.fn.velocity ? 'velocity' : 'animate'].apply(this, arguments);\n\t};\n\n\t//  And set up our jQuery plugin\n\t$.fn.unslider = function (opts) {\n\t\treturn this.each(function (index, elem) {\n\t\t\tvar $this = $(elem);\n\t\t\tvar unslider = $(elem).data('unslider');\n\t\t\tif (unslider instanceof $.Unslider) {\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t//  Allow usage of .unslider('function_name')\n\t\t\t//  as well as using .data('unslider') to access the\n\t\t\t//  main Unslider object\n\t\t\tif (typeof opts === 'string' && $this.data('unslider')) {\n\t\t\t\topts = opts.split(':');\n\n\t\t\t\tvar call = $this.data('unslider')[opts[0]];\n\n\t\t\t\t//  Do we have arguments to pass to the string-function?\n\t\t\t\tif ($.isFunction(call)) {\n\t\t\t\t\treturn call.apply($this, opts[1] ? opts[1].split(',') : null);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn $this.data('unslider', new $.Unslider($this, opts));\n\t\t});\n\t};\n});\n/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(1), __webpack_require__(17)(module), __webpack_require__(1)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\nmodule.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports) {\n\n// removed by extract-text-webpack-plugin\n\n/***/ })\n],[14]);\n\n\n// WEBPACK FOOTER //\n// js/unslider.js","/*\r\n * @Author: guidetheorient \r\n * @Date: 2018-04-05 05:34:17 \r\n * @Last Modified by: guidetheorient\r\n * @Last Modified time: 2018-04-05 05:55:51\r\n */\r\n\r\nrequire('./unslider.min.js');\r\nrequire('./unsilder.scss');\r\n\r\n\n\n\n// WEBPACK FOOTER //\n// ./src/tool/util/unslider/index.js","/**\r\n *   Unslider\r\n *   version 2.0\r\n *   by @idiot and friends\r\n */\r\n\r\n(function(factory) {\r\n\tif (typeof module === 'object' && typeof module.exports === 'object') {\r\n\t\tfactory(require('jquery'));\r\n\t} else if (typeof define === 'function' && define.amd) {\r\n\t    // AMD. Register as an anonymous module.\r\n        define([], factory(window.jQuery));\r\n    } else {\r\n\t\tfactory(window.jQuery);\r\n\t}\r\n}(function($) {\r\n\t//  Don't throw any errors when jQuery\r\n\tif(!$) {\r\n\t\treturn console.warn('Unslider needs jQuery');\r\n\t}\r\n\r\n\t$.Unslider = function(context, options) {\r\n\t\tvar self = this;\r\n\r\n\t\t//  Create an Unslider reference we can use everywhere\r\n\t\tself._ = 'unslider';\r\n\r\n\t\t//  Store our default options in here\r\n\t\t//  Everything will be overwritten by the jQuery plugin though\r\n\t\tself.defaults = {\r\n\t\t\t//  Should the slider move on its own or only when\r\n\t\t\t//  you interact with the nav/arrows?\r\n\t\t\t//  Only accepts boolean true/false.\r\n\t\t\tautoplay: false,\r\n\r\n\t\t\t//  3 second delay between slides moving, pass\r\n\t\t\t//  as a number in milliseconds.\r\n\t\t\tdelay: 3000,\r\n\r\n\t\t\t//  Animation speed in millseconds\r\n\t\t\tspeed: 750,\r\n\r\n\t\t\t//  An easing string to use. If you're using Velocity, use a\r\n\t\t\t//  Velocity string otherwise you can use jQuery/jQ UI options.\r\n\t\t\teasing: 'swing', // [.42, 0, .58, 1],\r\n\r\n\t\t\t//  Does it support keyboard arrows?\r\n\t\t\t//  Can pass either true or false -\r\n\t\t\t//  or an object with the keycodes, like so:\r\n\t\t\t//  {\r\n\t\t\t//\t prev: 37,\r\n\t\t\t//\t next: 39\r\n\t\t\t// }\r\n\t\t\t//  You can call any internal method name\r\n\t\t\t//  before the keycode and it'll be called.\r\n\t\t\tkeys: {\r\n\t\t\t\tprev: 37,\r\n\t\t\t\tnext: 39\r\n\t\t\t},\r\n\r\n\t\t\t//  Do you want to generate clickable navigation\r\n\t\t\t//  to skip to each slide? Accepts boolean true/false or\r\n\t\t\t//  a callback function per item to generate.\r\n\t\t\tnav: true,\r\n\r\n\t\t\t//  Should there be left/right arrows to go back/forth?\r\n\t\t\t//   -> This isn't keyboard support.\r\n\t\t\t//  Either set true/false, or an object with the HTML\r\n\t\t\t//  elements for each arrow like below:\r\n\t\t\tarrows: {\r\n\t\t\t\tprev: '<a class=\"' + self._ + '-arrow prev\">Prev</a>',\r\n\t\t\t\tnext: '<a class=\"' + self._ + '-arrow next\">Next</a>'\r\n\t\t\t},\r\n\r\n\t\t\t//  How should Unslider animate?\r\n\t\t\t//  It can do one of the following types:\r\n\t\t\t//  \"fade\": each slide fades in to each other\r\n\t\t\t//  \"horizontal\": each slide moves from left to right\r\n\t\t\t//  \"vertical\": each slide moves from top to bottom\r\n\t\t\tanimation: 'horizontal',\r\n\r\n\t\t\t//  If you don't want to use a list to display your slides,\r\n\t\t\t//  you can change it here. Not recommended and you'll need\r\n\t\t\t//  to adjust the CSS accordingly.\r\n\t\t\tselectors: {\r\n\t\t\t\tcontainer: 'ul:first',\r\n\t\t\t\tslides: 'li'\r\n\t\t\t},\r\n\r\n\t\t\t//  Do you want to animate the heights of each slide as\r\n\t\t\t//  it moves\r\n\t\t\tanimateHeight: false,\r\n\r\n\t\t\t//  Active class for the nav\r\n\t\t\tactiveClass: self._ + '-active',\r\n\r\n\t\t\t//  Have swipe support?\r\n\t\t\t//  You can set this here with a boolean and always use\r\n\t\t\t//  initSwipe/destroySwipe later on.\r\n\t\t\tswipe: true,\r\n\t\t\t// Swipe threshold -\r\n\t\t\t// lower float for enabling short swipe\r\n\t\t\tswipeThreshold: 0.2\r\n\t\t};\r\n\r\n\t\t//  Set defaults\r\n\t\tself.$context = context;\r\n\t\tself.options = {};\r\n\r\n\t\t//  Leave our elements blank for now\r\n\t\t//  Since they get changed by the options, we'll need to\r\n\t\t//  set them in the init method.\r\n\t\tself.$parent = null;\r\n\t\tself.$container = null;\r\n\t\tself.$slides = null;\r\n\t\tself.$nav = null;\r\n\t\tself.$arrows = [];\r\n\r\n\t\t//  Set our indexes and totals\r\n\t\tself.total = 0;\r\n\t\tself.current = 0;\r\n\r\n\t\t//  Generate a specific random ID so we don't dupe events\r\n\t\tself.prefix = self._ + '-';\r\n\t\tself.eventSuffix = '.' + self.prefix + ~~(Math.random() * 2e3);\r\n\r\n\t\t//  In case we're going to use the autoplay\r\n\t\tself.interval = [];\r\n\r\n\t\t//  Get everything set up innit\r\n\t\tself.init = function(options) {\r\n\t\t\t//  Set up our options inside here so we can re-init at\r\n\t\t\t//  any time\r\n\t\t\tself.options = $.extend({}, self.defaults, options);\r\n\r\n\t\t\t//  Our elements\r\n\t\t\tself.$container = self.$context.find(self.options.selectors.container).addClass(self.prefix + 'wrap');\r\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\r\n\r\n\t\t\t//  We'll manually init the container\r\n\t\t\tself.setup();\r\n\r\n\t\t\t//  We want to keep this script as small as possible\r\n\t\t\t//  so we'll optimise some checks\r\n\t\t\t$.each(['nav', 'arrows', 'keys', 'infinite'], function(index, module) {\r\n\t\t\t\tself.options[module] && self['init' + $._ucfirst(module)]();\r\n\t\t\t});\r\n\r\n\t\t\t//  Add swipe support\r\n\t\t\tif(jQuery.event.special.swipe && self.options.swipe) {\r\n\t\t\t\tself.initSwipe();\r\n\t\t\t}\r\n\r\n\t\t\t//  If autoplay is set to true, call self.start()\r\n\t\t\t//  to start calling our timeouts\r\n\t\t\tself.options.autoplay && self.start();\r\n\r\n\t\t\t//  We should be able to recalculate slides at will\r\n\t\t\tself.calculateSlides();\r\n\r\n\t\t\t//  Listen to a ready event\r\n\t\t\tself.$context.trigger(self._ + '.ready');\r\n\r\n\t\t\t//  Everyday I'm chainin'\r\n\t\t\treturn self.animate(self.options.index || self.current, 'init');\r\n\t\t};\r\n\r\n\t\tself.setup = function() {\r\n\t\t\t//  Add a CSS hook to the main element\r\n\t\t\tself.$context.addClass(self.prefix + self.options.animation).wrap('<div class=\"' + self._ + '\" />');\r\n\t\t\tself.$parent = self.$context.parent('.' + self._);\r\n\r\n\t\t\t//  We need to manually check if the container is absolutely\r\n\t\t\t//  or relatively positioned\r\n\t\t\tvar position = self.$context.css('position');\r\n\r\n\t\t\t//  If we don't already have a position set, we'll\r\n\t\t\t//  automatically set it ourselves\r\n\t\t\tif(position === 'static') {\r\n\t\t\t\tself.$context.css('position', 'relative');\r\n\t\t\t}\r\n\r\n\t\t\tself.$context.css('overflow', 'hidden');\r\n\t\t};\r\n\r\n\t\t//  Set up the slide widths to animate with\r\n\t\t//  so the box doesn't float over\r\n\t\tself.calculateSlides = function() {\r\n\t\t\t// update slides before recalculating the total\r\n\t\t\tself.$slides = self.$container.children(self.options.selectors.slides);\r\n\r\n\t\t\tself.total = self.$slides.length;\r\n\r\n\t\t\t//  Set the total width\r\n\t\t\tif(self.options.animation !== 'fade') {\r\n\t\t\t\tvar prop = 'width';\r\n\r\n\t\t\t\tif(self.options.animation === 'vertical') {\r\n\t\t\t\t\tprop = 'height';\r\n\t\t\t\t}\r\n\r\n\t\t\t\tself.$container.css(prop, (self.total * 100) + '%').addClass(self.prefix + 'carousel');\r\n\t\t\t\tself.$slides.css(prop, (100 / self.total) + '%');\r\n\t\t\t}\r\n\t\t};\r\n\r\n\r\n\t\t//  Start our autoplay\r\n\t\tself.start = function() {\r\n\t\t\tself.interval.push(setTimeout(function() {\r\n\t\t\t\t//  Move on to the next slide\r\n\t\t\t\tself.next();\r\n\r\n\t\t\t\t//  If we've got autoplay set up\r\n\t\t\t\t//  we don't need to keep starting\r\n\t\t\t\t//  the slider from within our timeout\r\n\t\t\t\t//  as .animate() calls it for us\r\n\t\t\t}, self.options.delay));\r\n\r\n\t\t\treturn self;\r\n\t\t};\r\n\r\n\t\t//  And pause our timeouts\r\n\t\t//  and force stop the slider if needed\r\n\t\tself.stop = function() {\r\n            var timeout;\r\n            while(timeout = self.interval.pop()) {\r\n                clearTimeout(timeout);\r\n            }\r\n\r\n\t\t\treturn self;\r\n\t\t};\r\n\r\n\r\n\t\t//  Set up our navigation\r\n\t\tself.initNav = function() {\r\n\t\t\tvar $nav = $('<nav class=\"' + self.prefix + 'nav\"><ol /></nav>');\r\n\r\n\t\t\t//  Build our click navigation item-by-item\r\n\t\t\tself.$slides.each(function(key) {\r\n\t\t\t\t//  If we've already set a label, let's use that\r\n\t\t\t\t//  instead of generating one\r\n\t\t\t\tvar label = this.getAttribute('data-nav') || key + 1;\r\n\r\n\t\t\t\t//  Listen to any callback functions\r\n\t\t\t\tif($.isFunction(self.options.nav)) {\r\n\t\t\t\t\tlabel = self.options.nav.call(self.$slides.eq(key), key, label);\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//  And add it to our navigation item\r\n\t\t\t\t$nav.children('ol').append('<li data-slide=\"' + key + '\">' + label + '</li>');\r\n\t\t\t});\r\n\r\n\t\t\t//  Keep a copy of the nav everywhere so we can use it\r\n\t\t\tself.$nav = $nav.insertAfter(self.$context);\r\n\r\n\t\t\t//  Now our nav is built, let's add it to the slider and bind\r\n\t\t\t//  for any click events on the generated links\r\n\t\t\tself.$nav.find('li').on('mouseenter' + self.eventSuffix, function(e) {\r\n\t\t\t\t//  Cache our link and set it to be active\r\n\t\t\t\tvar $me = $(this).addClass(self.options.activeClass);\r\n\r\n\t\t\t\t//  Set the right active class, remove any other ones\r\n\t\t\t\t$me.siblings().removeClass(self.options.activeClass);\r\n\r\n\t\t\t\t//  Move the slide\r\n\t\t\t\tself.animate($me.attr('data-slide'));\r\n\t\t\t});\r\n\t\t};\r\n\r\n\r\n\t\t//  Set up our left-right arrow navigation\r\n\t\t//  (Not keyboard arrows, prev/next buttons)\r\n\t\tself.initArrows = function() {\r\n\t\t\tif(self.options.arrows === true) {\r\n\t\t\t\tself.options.arrows = self.defaults.arrows;\r\n\t\t\t}\r\n\r\n\t\t\t//  Loop our options object and bind our events\r\n\t\t\t$.each(self.options.arrows, function(key, val) {\r\n\t\t\t\t//  Add our arrow HTML and bind it\r\n\r\n\t\t\t\tself.$arrows.push(\r\n\t\t\t\t\t$(val).insertAfter(self.$context).on('click' + self.eventSuffix, self[key])\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\r\n\t\t//  Set up our keyboad navigation\r\n\t\t//  Allow binding to multiple keycodes\r\n\t\tself.initKeys = function() {\r\n\t\t\tif(self.options.keys === true) {\r\n\t\t\t\tself.options.keys = self.defaults.keys;\r\n\t\t\t}\r\n\r\n\t\t\t$(document).on('keyup' + self.eventSuffix, function(e) {\r\n\t\t\t\t$.each(self.options.keys, function(key, val) {\r\n\t\t\t\t\tif(e.which === val) {\r\n\t\t\t\t\t\t$.isFunction(self[key]) && self[key].call(self);\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t//  Requires jQuery.event.swipe\r\n\t\t//  -> stephband.info/jquery.event.swipe\r\n\t\tself.initSwipe = function() {\r\n\t\t\tvar width = self.$slides.width();\r\n\r\n\t\t\t//  We don't want to have a tactile swipe in the slider\r\n\t\t\t//  in the fade animation, as it can cause some problems\r\n\t\t\t//  with layout, so we'll just disable it.\r\n\t\t\tif(self.options.animation !== 'fade') {\r\n\r\n\t\t\t\tself.$container.on({\r\n\r\n\t\t\t\t\tmovestart: function(e) {\r\n\t\t\t\t\t\t//  If the movestart heads off in a upwards or downwards\r\n\t\t\t\t\t\t//  direction, prevent it so that the browser scrolls normally.\r\n\t\t\t\t\t\tif((e.distX > e.distY && e.distX < -e.distY) || (e.distX < e.distY && e.distX > -e.distY)) {\r\n\t\t\t\t\t\t\treturn !!e.preventDefault();\r\n\t\t\t\t\t\t}\r\n\r\n\t\t\t\t\t\tself.$container.css('position', 'relative');\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tmove: function(e) {\r\n\t\t\t\t\t\tself.$container.css('left', -(100 * self.current) + (100 * e.distX / width) + '%');\r\n\t\t\t\t\t},\r\n\r\n\t\t\t\t\tmoveend: function(e) {\r\n\t\t\t\t\t\t// Check if swiped distance is greater than threshold.\r\n\t\t\t\t\t\t// If yes slide to next/prev slide. If not animate to\r\n\t\t\t\t\t\t// starting point.\r\n\r\n\t\t\t\t\t\tif((Math.abs(e.distX) / width) > self.options.swipeThreshold) {\r\n\r\n\t\t\t\t\t\t\tself[e.distX < 0 ? 'next' : 'prev']();\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\telse {\r\n\r\n\t\t\t\t\t\t\tself.$container.animate({left: -(100 * self.current) + '%' }, self.options.speed / 2 );\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t}\r\n\t\t\t\t});\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\t//  Infinite scrolling is a massive pain in the arse\r\n\t\t//  so we need to create a whole bloody function to set\r\n\t\t//  it up. Argh.\r\n\t\tself.initInfinite = function() {\r\n\t\t\tvar pos = ['first', 'last'];\r\n\r\n\t\t\t$.each(pos, function(index, item) {\r\n\t\t\t\tself.$slides.push.apply(\r\n\t\t\t\t\tself.$slides,\r\n\r\n\t\t\t\t\t//  Exclude all cloned slides and call .first() or .last()\r\n\t\t\t\t\t//  depending on what `item` is.\r\n\t\t\t\t\tself.$slides.filter(':not(\".' + self._ + '-clone\")')[item]()\r\n\r\n\t\t\t\t\t//  Make a copy of it and identify it as a clone\r\n\t\t\t\t\t.clone().addClass(self._ + '-clone')\r\n\r\n\t\t\t\t\t//  Either insert before or after depending on whether we're\r\n\t\t\t\t\t//  the first or last clone\r\n\t\t\t\t\t['insert' + (index === 0 ? 'After' : 'Before')](\r\n\t\t\t\t\t\t//  Return the other element in the position array\r\n\t\t\t\t\t\t//  if item = first, return \"last\"\r\n\t\t\t\t\t\tself.$slides[pos[~~!index]]()\r\n\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t//  Remove any trace of arrows\r\n\t\t//  Loop our array of arrows and use jQuery to remove\r\n\t\t//  It'll unbind any event handlers for us\r\n\t\tself.destroyArrows = function() {\r\n\t\t\t$.each(self.$arrows, function(i, $arrow) {\r\n\t\t\t\t$arrow.remove();\r\n\t\t\t});\r\n\t\t};\r\n\r\n\t\t//  Remove any swipe events and reset the position\r\n\t\tself.destroySwipe = function() {\r\n\t\t\t//  We bind to 4 events, so we'll unbind those\r\n\t\t\tself.$container.off('movestart move moveend');\r\n\t\t};\r\n\r\n\t\t//  Unset the keyboard navigation\r\n\t\t//  Remove the handler\r\n\t\tself.destroyKeys = function() {\r\n\t\t\t//  Remove the event handler\r\n\t\t\t$(document).off('keyup' + self.eventSuffix);\r\n\t\t};\r\n\r\n\t\tself.setIndex = function(to) {\r\n\t\t\tif(to < 0) {\r\n\t\t\t\tto = self.total - 1;\r\n\t\t\t}\r\n\r\n\t\t\tself.current = Math.min(Math.max(0, to), self.total - 1);\r\n\r\n\t\t\tif(self.options.nav) {\r\n\t\t\t\tself.$nav.find('[data-slide=\"' + self.current + '\"]')._active(self.options.activeClass);\r\n\t\t\t}\r\n\r\n\t\t\tself.$slides.eq(self.current)._active(self.options.activeClass);\r\n\r\n\t\t\treturn self;\r\n\t\t};\r\n\r\n\t\t//  Despite the name, this doesn't do any animation - since there's\r\n\t\t//  now three different types of animation, we let this method delegate\r\n\t\t//  to the right type, keeping the name for backwards compat.\r\n\t\tself.animate = function(to, dir) {\r\n\t\t\t//  Animation shortcuts\r\n\t\t\t//  Instead of passing a number index, we can now\r\n\t\t\t//  use .data('unslider').animate('last');\r\n\t\t\t//  or .unslider('animate:last')\r\n\t\t\t//  to go to the very last slide\r\n\t\t\tif(to === 'first') to = 0;\r\n\t\t\tif(to === 'last') to = self.total;\r\n\r\n\t\t\t//  Don't animate if it's not a valid index\r\n\t\t\tif(isNaN(to)) {\r\n\t\t\t\treturn self;\r\n\t\t\t}\r\n\r\n\t\t\tif(self.options.autoplay) {\r\n\t\t\t\tself.stop().start();\r\n\t\t\t}\r\n\r\n\t\t\tself.setIndex(to);\r\n\r\n\t\t\t//  Add a callback method to do stuff with\r\n\t\t\tself.$context.trigger(self._ + '.change', [to, self.$slides.eq(to)]);\r\n\r\n\t\t\t//  Delegate the right method - everything's named consistently\r\n\t\t\t//  so we can assume it'll be called \"animate\" +\r\n\t\t\tvar fn = 'animate' + $._ucfirst(self.options.animation);\r\n\r\n\t\t\t//  Make sure it's a valid animation method, otherwise we'll get\r\n\t\t\t//  a load of bug reports that'll be really hard to report\r\n\t\t\tif($.isFunction(self[fn])) {\r\n\t\t\t\tself[fn](self.current, dir);\r\n\t\t\t}\r\n\r\n\t\t\treturn self;\r\n\t\t};\r\n\r\n\r\n\t\t//  Shortcuts for animating if we don't know what the current\r\n\t\t//  index is (i.e back/forward)\r\n\t\t//  For moving forward we need to make sure we don't overshoot.\r\n\t\tself.next = function() {\r\n\t\t\tvar target = self.current + 1;\r\n\r\n\t\t\t//  If we're at the end, we need to move back to the start\r\n\t\t\tif(target >= self.total) {\r\n\t\t\t\tif(self.options.noloop && !self.options.infinite) {\r\n\t\t\t\t\ttarget = self.total - 1;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget = 0;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn self.animate(target, 'next');\r\n\t\t};\r\n\r\n\t\t//  The same as next, but the opposite :)\r\n\t\tself.prev = function() {\r\n\t\t\tvar target = self.current - 1;\r\n\r\n\t\t\t//  If we're at the first, we need to move forward to the end\r\n\t\t\tif(target < 0) {\r\n\t\t\t\tif(self.options.noloop && !self.options.infinite) {\r\n\t\t\t\t\ttarget = 0;\r\n\t\t\t\t} else {\r\n\t\t\t\t\ttarget = self.total - 1;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\t\r\n\t\t\treturn self.animate(target, 'prev');\r\n\t\t};\r\n\r\n\r\n\t\t//  Our default animation method, the old-school left-to-right\r\n\t\t//  horizontal animation\r\n\t\tself.animateHorizontal = function(to) {\r\n\t\t\tvar prop = 'left';\r\n\r\n\t\t\t//  Add RTL support, slide the slider\r\n\t\t\t//  the other way if the site is right-to-left\r\n\t\t\tif(self.$context.attr('dir') === 'rtl') {\r\n\t\t\t\tprop = 'right';\r\n\t\t\t}\r\n\r\n\t\t\tif(self.options.infinite) {\r\n\t\t\t\t//  So then we need to hide the first slide\r\n\t\t\t\tself.$container.css('margin-' + prop, '-100%');\r\n\t\t\t}\r\n\r\n\t\t\treturn self.slide(prop, to);\r\n\t\t};\r\n\r\n\t\t//  The same animation methods, but vertical support\r\n\t\t//  RTL doesn't affect the vertical direction so we\r\n\t\t//  can just call as is\r\n\t\tself.animateVertical = function(to) {\r\n\t\t\tself.options.animateHeight = true;\r\n\r\n\t\t\t//  Normal infinite CSS fix doesn't work for\r\n\t\t\t//  vertical animation so we need to manually set it\r\n\t\t\t//  with pixels. Ah well.\r\n\t\t\tif(self.options.infinite) {\r\n\t\t\t\tself.$container.css('margin-top', -self.$slides.outerHeight());\r\n\t\t\t}\r\n\r\n\t\t\treturn self.slide('top', to);\r\n\t\t};\r\n\r\n\t\t//  Actually move the slide now\r\n\t\t//  We have to pass a property to animate as there's\r\n\t\t//  a few different directions it can now move, but it's\r\n\t\t//  otherwise unchanged from before.\r\n\t\tself.slide = function(prop, to) {\r\n\t\t\t//  If we want to change the height of the slider\r\n\t\t\t//  to match the current slide, you can set\r\n\t\t\t//  {animateHeight: true}\r\n\t\t\tself.animateHeight(to);\r\n\r\n\t\t\t//  For infinite sliding we add a dummy slide at the end and start\r\n\t\t\t//  of each slider to give the appearance of being infinite\r\n\t\t\tif(self.options.infinite) {\r\n\t\t\t\tvar dummy;\r\n\r\n\t\t\t\t//  Going backwards to last slide\r\n\t\t\t\tif(to === self.total - 1) {\r\n\t\t\t\t\t//  We're setting a dummy position and an actual one\r\n\t\t\t\t\t//  the dummy is what the index looks like\r\n\t\t\t\t\t//  (and what we'll silently update to afterwards),\r\n\t\t\t\t\t//  and the actual is what makes it not go backwards\r\n\t\t\t\t\tdummy = self.total - 3;\r\n\t\t\t\t\tto = -1;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//  Going forwards to first slide\r\n\t\t\t\tif(to === self.total - 2) {\r\n\t\t\t\t\tdummy = 0;\r\n\t\t\t\t\tto = self.total - 2;\r\n\t\t\t\t}\r\n\r\n\t\t\t\t//  If it's a number we can safely set it\r\n\t\t\t\tif(typeof dummy === 'number') {\r\n\t\t\t\t\tself.setIndex(dummy);\r\n\r\n\t\t\t\t\t//  Listen for when the slide's finished transitioning so\r\n\t\t\t\t\t//  we can silently move it into the right place and clear\r\n\t\t\t\t\t//  this whole mess up.\r\n\t\t\t\t\tself.$context.on(self._ + '.moved', function() {\r\n\t\t\t\t\t\tif(self.current === dummy) {\r\n\t\t\t\t\t\t\tself.$container.css(prop, -(100 * dummy) + '%').off(self._ + '.moved');\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\t//  We need to create an object to store our property in\r\n\t\t\t//  since we don't know what it'll be.\r\n\t\t\tvar obj = {};\r\n\r\n\t\t\t//  Manually create it here\r\n\t\t\tobj[prop] = -(100 * to) + '%';\r\n\r\n\t\t\t//  And animate using our newly-created object\r\n\t\t\treturn self._move(self.$container, obj);\r\n\t\t};\r\n\r\n\r\n\t\t//  Fade between slides rather than, uh, sliding it\r\n    // self.animateFade = function(to) {\r\n\t\t// \t//  If we want to change the height of the slider\r\n\t\t// \t//  to match the current slide, you can set\r\n\t\t// \t//  {animateHeight: true}\r\n\t\t// \tself.animateHeight(to);\r\n\r\n\t\t\t\r\n\t\t// \tvar $active = self.$slides.eq(to).addClass(self.options.activeClass);\r\n\r\n\t\t// \t//  Toggle our classes\r\n\t\t// \t$active.css({opacity: 1}).siblings().css({opacity: 0});\r\n\t\t// };\r\n\r\n\t\t// Animate height of slider\r\n\t\tself.animateHeight = function(to) {\r\n\t\t\t//  If we want to change the height of the slider\r\n\t\t\t//  to match the current slide, you can set\r\n\t\t\t//  {animateHeight: true}\r\n\t\t\tif (self.options.animateHeight) {\r\n\t\t\t\tself._move(self.$context, {height: self.$slides.eq(to).outerHeight()}, false);\r\n\t\t\t}\r\n\t\t};\r\n\r\n\t\tself._move = function($el, obj, callback, speed) {\r\n\t\t\tif(callback !== false) {\r\n\t\t\t\tcallback = function() {\r\n\t\t\t\t\tself.$context.trigger(self._ + '.moved');\r\n\t\t\t\t};\r\n\t\t\t}\r\n\r\n\t\t\treturn $el._move(obj, speed || self.options.speed, self.options.easing, callback);\r\n\t\t};\r\n\r\n\t\t//  Allow daisy-chaining of methods\r\n\t\treturn self.init(options);\r\n\t};\r\n\r\n\t//  Internal (but global) jQuery methods\r\n\t//  They're both just helpful types of shorthand for\r\n\t//  anything that might take too long to write out or\r\n\t//  something that might be used more than once.\r\n\t$.fn._active = function(className) {\r\n\t\treturn this.addClass(className).siblings().removeClass(className);\r\n\t};\r\n\r\n\t//  The equivalent to PHP's ucfirst(). Take the first\r\n\t//  character of a string and make it uppercase.\r\n\t//  Simples.\r\n\t$._ucfirst = function(str) {\r\n\t\t//  Take our variable, run a regex on the first letter\r\n\t\treturn (str + '').toLowerCase().replace(/^./, function(match) {\r\n\t\t\t//  And uppercase it. Simples.\r\n\t\t\treturn match.toUpperCase();\r\n\t\t});\r\n\t};\r\n\r\n\t$.fn._move = function() {\r\n\t\tthis.stop(true, true);\r\n\t\treturn $.fn[$.fn.velocity ? 'velocity' : 'animate'].apply(this, arguments);\r\n\t};\r\n\r\n\t//  And set up our jQuery plugin\r\n\t$.fn.unslider = function(opts) {\r\n\t\treturn this.each(function(index,elem) {\r\n\t\t\tvar $this = $(elem);\r\n            var unslider = $(elem).data('unslider');\r\n            if(unslider instanceof $.Unslider) {\r\n                return;\r\n            }\r\n\t\t\t//  Allow usage of .unslider('function_name')\r\n\t\t\t//  as well as using .data('unslider') to access the\r\n\t\t\t//  main Unslider object\r\n\t\t\tif(typeof opts === 'string' && $this.data('unslider')) {\r\n\t\t\t\topts = opts.split(':');\r\n\r\n\t\t\t\tvar call = $this.data('unslider')[opts[0]];\r\n\r\n\t\t\t\t//  Do we have arguments to pass to the string-function?\r\n\t\t\t\tif($.isFunction(call)) {\r\n\t\t\t\t\treturn call.apply($this, opts[1] ? opts[1].split(',') : null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\r\n\t\t\treturn $this.data('unslider', new $.Unslider($this, opts));\r\n\t\t});\r\n\t};\r\n\r\n}));\n\n\n// WEBPACK FOOTER //\n// ./src/tool/util/unslider/unslider.min.js","module.exports = function(module) {\r\n\tif(!module.webpackPolyfill) {\r\n\t\tmodule.deprecate = function() {};\r\n\t\tmodule.paths = [];\r\n\t\t// module.parent = undefined by default\r\n\t\tif(!module.children) module.children = [];\r\n\t\tObject.defineProperty(module, \"loaded\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.l;\r\n\t\t\t}\r\n\t\t});\r\n\t\tObject.defineProperty(module, \"id\", {\r\n\t\t\tenumerable: true,\r\n\t\t\tget: function() {\r\n\t\t\t\treturn module.i;\r\n\t\t\t}\r\n\t\t});\r\n\t\tmodule.webpackPolyfill = 1;\r\n\t}\r\n\treturn module;\r\n};\r\n\n\n\n//////////////////\n// WEBPACK FOOTER\n// (webpack)/buildin/module.js\n// module id = 17\n// module chunks = 3"],"sourceRoot":""}